# Задача 2: аппроксимация функции
#
# Рассмотрим сложную математическую функцию на отрезке [1, 15]:
# f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)
#
# Она может описывать, например, зависимость оценок, которые выставляют определенному сорту вина эксперты,
# в зависимости от возраста этого вина. По сути, задача машинного обучения состоит в том, чтобы приблизить
# сложную зависимость с помощью функции из определенного семейства. В этом задании мы будем приближать
# указанную функцию с помощью многочленов.
#
# Как известно, многочлен степени n (то есть w_0 + w_1 x + w_2 x^2 + ... + w_n x^n) однозначно определяется
# любыми n + 1 различными точками, через которые он проходит. Это значит, что его коэффициенты w_0, ... w_n
# можно определить из следующей системы линейных уравнений:
# w0 + w1 x1 + w2 x1^2 + ... + wn x1^n = f(x1)
# ...
# w0 + w1 xn+1 + w2 xn+1^2 + ... + wn xn+1^n = f(xn+1)
# где через x_1, ..., x_n, x_{n+1} обозначены точки, через которые проходит многочлен, а через
# f(x_1), ..., f(x_n), f(x_{n+1}) — значения, которые он должен принимать в этих точках.
#
# Воспользуемся описанным свойством, и будем находить приближение функции многочленом,
# решая систему линейных уравнений.
#
# 1. Сформируйте систему линейных уравнений (то есть задайте матрицу коэффициентов A и свободный вектор b)
# для многочлена первой степени, который должен совпадать с функцией f в точках 1 и 15. Решите данную систему
# с помощью функции scipy.linalg.solve. Нарисуйте функцию f и полученный многочлен.
# Хорошо ли он приближает исходную функцию?
# 2. Повторите те же шаги для многочлена второй степени, который совпадает с функцией f в точках 1, 8 и 15.
# Улучшилось ли качество аппроксимации?
# 3. Повторите те же шаги для многочлена третьей степени, который совпадает с функцией f в точках 1, 4, 10 и 15.
# Хорошо ли он аппроксимирует функцию? Коэффициенты данного многочлена (четыре числа в следующем порядке:
# w_0, w_1, w_2, w_3) являются ответом на задачу. Округлять коэффициенты не обязательно, но при желании
# можете произвести округление до второго знака (т.е. до числа вида 0.42)
# 4. Запишите полученные числа в файл, разделив пробелами. Обратите внимание, что файл должен состоять из одной строки,
# в конце которой не должно быть переноса. Пример файла с решением вы можете найти в конце задания (submission-2.txt).

import math
import numpy
import matplotlib.pyplot as plt

def f(x):
    return math.sin(x / 5) * math.exp(x / 10) + 5 * math.exp(-x / 2)
    # Аналогичные функции существуют в numpy!
    # return sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)

def fn(x, c):
    return [sum(c[j] * x[i] ** j for j in range(len(c))) for i in range(len(x))]

min, max, step = 1, 15, 0.1
x = [min, 4, 10, max]
rangem = range(len(x))
y = [f(x[i]) for i in rangem]
print(x, y)
# Ax = b
Xn = [[x[i]**j for j in rangem] for i in rangem]
# print(Xn)
A = numpy.array(Xn)
b = numpy.array(y)
# print(numpy.linalg.det(A))
w = numpy.linalg.solve(A, b)
# print(w)
x = numpy.arange(min, max, step)  # Массив значений аргумента
y = fn(x, w)
# print(x, y, sep="\n")
plt.plot(x, y)  # Построение графика
plt.xlabel(r'$x$')  # Метка по оси x в формате TeX
plt.ylabel(r'$f(x)$')  # Метка по оси y в формате TeX
plt.grid(True)  # Сетка
plt.show()  # Показать график
with open("function_approximation.txt", "w") as outFile:
    outFile.write(" ".join(map(str, w)))
numpy.around(w, 4, w) # Округляем до 4ех знаков
print(w)
# [ 4.3626 -1.2955  0.1933 -0.0082]


# Введение
# В этом задании вы познакомитесь с некоторыми базовыми методами из линейной алгебры, реализованными в пакете SciPy —
# в частности, с методами подсчета косинусного расстояния и решения систем линейных уравнений. Обе эти задачи
# еще много раз встретятся нам в специализации. Так, на решении систем линейных уравнений основана настройка
# линейных моделей — очень большого и важного класса алгоритмов машинного обучения. Косинусное расстояние же
# часто используется в анализе текстов для измерения сходства между ними.
#
#
# Материалы
# Справка по функциям пакета scipy.linalg: http://docs.scipy.org/doc/scipy/reference/linalg.html
# Справка по работе с файлами в Python: https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files
# Справка по регулярным выражениям в Python (если вы захотите узнать про них чуть больше): https://docs.python.org/2/library/re.html
#
# Документация matplotlib: http://matplotlib.org/api/pyplot_api.html

'''
Если вы смотрели практикум, то там как раз показано как искать коэффициенты.
Для w0 - это 1 всегда.
Для w1 это x.
Для w2 это x**2
и т.д.
Т.е. их можно вручную найти. Или использовать матрицу Вандермонда (np.vander), только учитывая, 
что в ней порядок немного отличается! Т.е. надо вручную "отразить" матрицу.
'''

'''
Какие темы изучить/повторить?
функции (def)
numpy.array([])
Составление матрицы для решения системы линейных уравнений
numpy.linalg.solve()
'''

# https://github.com/Coursera-machine-learning-data-analysis/1/blob/master/1.ipynb
