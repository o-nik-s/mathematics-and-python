# Задача 3. Минимизация негладкой функции
# 1. Теперь рассмотрим функцию h(x) = int(f(x)) на том же отрезке [1, 30], т.е. теперь каждое значение f(x)
# приводится к типу int и функция принимает только целые значения.
# 2. Такая функция будет негладкой и даже разрывной, а ее график будет иметь ступенчатый вид.
# Убедитесь в этом, построив график h(x) с помощью matplotlib.
# 3. Попробуйте найти минимум функции h(x) с помощью BFGS, взяв в качестве начального приближения x=30.
# Получившееся значение функции – ваш первый ответ в этой задаче.
# 4. Теперь попробуйте найти минимум h(x) на отрезке [1, 30] с помощью дифференциальной эволюции.
# Значение функции h(x) в точке минимума – это ваш второй ответ в этом задании.
# Запишите его через пробел после предыдущего.
# 5. Обратите внимание на то, что полученные ответы различаются. Это ожидаемый результат, ведь BFGS использует градиент
# (в одномерном случае – производную) и явно не пригоден для минимизации рассмотренной нами разрывной функции.
# Попробуйте понять, почему минимум, найденный BFGS, именно такой (возможно в этом вам поможет выбор
# разных начальных приближений).
# 6. Выполнив это задание, вы увидели на практике, чем поиск минимума функции отличается от глобальной оптимизации,
# и когда может быть полезно применить вместо градиентного метода оптимизации метод, не использующий градиент.
# Кроме того, вы попрактиковались в использовании библиотеки SciPy для решения оптимизационных задач, и теперь знаете,
# насколько это просто и удобно.


import math
from scipy.optimize import minimize, differential_evolution
import numpy as np
import matplotlib.pyplot as plt


def f(x):
    return math.sin(x / 5) * math.exp(x / 10) + 5 * math.exp(-x / 2)


def h(x):
    return int(f(x))


min, max, step = 0, 30, 0.1
x = np.arange(min, max, step)  # Массив значений аргумента
y = np.array([h(x[i]) for i in range(len(x))])
# print(x, y, sep="\n")
plt.plot(x, y)  # Построение графика
plt.xlabel(r'$x$')  # Метка по оси x в формате TeX
plt.ylabel(r'$f(x)$')  # Метка по оси y в формате TeX
plt.grid(True)  # Сетка
plt.show()  # Показать график

res, x0 = [], 30
res.append(minimize(fun=h, x0=x0, method="BFGS"))
print(res[0])
print(round(res[0].fun)) # Первый ответ на задание

res.append(differential_evolution(func=h, bounds=[(min, max)]))
print(res[1])
print(round(res[1].fun)) # Второй ответ на задание

with open("nonsmooth_function_minimization.txt", "w") as outFile:
    outFile.write(" ".join(map(str, (round(res[0].fun), round(res[1].fun)))))
